<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Boost IDL Library: boost/idl/method.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>boost/idl/method.hpp</h1><a href="method_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef BOOST_PP_IS_ITERATING</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span>    <span class="comment">//#ifndef _BOOST_IDL_METHOD_HPP_</span>
<a name="l00003"></a>00003     <span class="comment">//#define _BOOST_IDL_METHOD_HPP_</span>
<a name="l00004"></a>00004 <span class="preprocessor">    #include &lt;<a class="code" href="fast__delegate_8hpp.html">boost/idl/fast_delegate.hpp</a>&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">    #include &lt;boost/typeof/typeof.hpp&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">    #include &lt;boost/function.hpp&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">    #include &lt;boost/bind.hpp&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">    #include &lt;boost/type_traits/function_traits.hpp&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">    #include &lt;boost/preprocessor/repetition.hpp&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">    #include &lt;boost/preprocessor/seq/for_each.hpp&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">    #include &lt;boost/type_traits/remove_pointer.hpp&gt;</span>
<a name="l00012"></a>00012 
<a name="l00013"></a><a class="code" href="method_8hpp.html#a997e932bcde763683042e78343c34186">00013</a> <span class="preprocessor">    #define PARAM_NAME(z,n,type)    BOOST_PP_CAT(a,n)</span>
<a name="l00014"></a><a class="code" href="method_8hpp.html#a4b65a1710d3a32349380f74be0ef82ca">00014</a> <span class="preprocessor"></span><span class="preprocessor">    #define PARAM_TYPE(z,n,type)    BOOST_PP_CAT(BOOST_PP_CAT(typename traits::arg,BOOST_PP_ADD(n,1)),_type)</span>
<a name="l00015"></a><a class="code" href="method_8hpp.html#a576db89c791d4eab998cabcec09e5783">00015</a> <span class="preprocessor"></span><span class="preprocessor">    #define PARAM_ARG(z,n,type)     PARAM_TYPE(z,n,type) PARAM_NAME(z,n,type)</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span>
<a name="l00017"></a>00017     <span class="keyword">namespace </span>boost { <span class="keyword">namespace </span>idl { <span class="keyword">namespace </span>detail {
<a name="l00018"></a>00018 
<a name="l00019"></a>00019         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Class, <span class="keyword">typename</span> Signature, <span class="keywordtype">bool</span> is_const = false&gt;
<a name="l00020"></a>00020         <span class="keyword">struct </span>member_from_signature 
<a name="l00021"></a>00021         {
<a name="l00022"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member__from__signature.html#a045a9af058394b8d4339bf25583a4a9a">00022</a>             <span class="keyword">typedef</span> Signature Class::*  <a class="code" href="structboost_1_1idl_1_1detail_1_1member__from__signature.html#a045a9af058394b8d4339bf25583a4a9a">type</a>;
<a name="l00023"></a>00023         <span class="comment">/*BOOST_STATIC_ASSERT(false);*/</span> 
<a name="l00024"></a>00024         };
<a name="l00025"></a>00025         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00026"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1get__function__type.html#a8430ca59a293fb1fa6a497eb2f803e74">00026</a>         <span class="keyword">struct </span><a class="code" href="structboost_1_1idl_1_1detail_1_1get__function__type.html">get_function_type</a> { <span class="keyword">typedef</span> T <a class="code" href="structboost_1_1idl_1_1detail_1_1get__function__type.html#a8430ca59a293fb1fa6a497eb2f803e74">type</a>; };
<a name="l00027"></a>00027 
<a name="l00028"></a>00028         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> arity, <span class="keyword">typename</span> Signature, <span class="keywordtype">bool</span> IsConst = false&gt;
<a name="l00029"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1method.html">00029</a>         <span class="keyword">struct </span><a class="code" href="structboost_1_1idl_1_1detail_1_1method.html">method</a>
<a name="l00030"></a>00030         {
<a name="l00031"></a>00031             <span class="comment">/*</span>
<a name="l00032"></a>00032 <span class="comment">            typename boost::function_traits&lt;Signature&gt;::result_type operator()(); </span>
<a name="l00033"></a>00033 <span class="comment">            method operator=( const boost::function&lt;Signature&gt;&amp; s );</span>
<a name="l00034"></a>00034 <span class="comment">            private:</span>
<a name="l00035"></a>00035 <span class="comment">                boost::function&lt;Signature&gt; m_delegate;</span>
<a name="l00036"></a>00036 <span class="comment">                */</span>
<a name="l00037"></a>00037         };
<a name="l00038"></a>00038         <span class="keyword">namespace </span>detail {
<a name="l00039"></a>00039         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> M&gt;
<a name="l00040"></a>00040             <span class="keyword">static</span> M&amp; do_get( C* c, M C::* m )
<a name="l00041"></a>00041             { <span class="keywordflow">return</span> c-&gt;*m; }
<a name="l00042"></a>00042         }
<a name="l00043"></a>00043 
<a name="l00044"></a>00044         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Class, <span class="keyword">typename</span> MemberType&gt;
<a name="l00045"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html">00045</a>         <span class="keyword">struct </span><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html">member</a>
<a name="l00046"></a>00046         {
<a name="l00047"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a935b7b41517b76b84ecbc5288f79a202">00047</a>             <span class="keyword">typedef</span> MemberType <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a935b7b41517b76b84ecbc5288f79a202">signature</a>;
<a name="l00048"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a9d68b5c7d7c93ba43a4093b06e84693a">00048</a>             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a9d68b5c7d7c93ba43a4093b06e84693a">is_const</a> = <span class="keyword">false</span>;
<a name="l00049"></a>00049 
<a name="l00050"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#ab7107f69b2c31d5b50b65856bf3bf5ad">00050</a>             <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#ab7107f69b2c31d5b50b65856bf3bf5ad">operator MemberType&amp; </a>()
<a name="l00051"></a>00051             {
<a name="l00052"></a>00052                 <span class="keywordflow">return</span> <span class="keyword">get</span>();
<a name="l00053"></a>00053             }
<a name="l00054"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#ac429cb9fcc9f86b332104713b84b2491">00054</a>             <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#ac429cb9fcc9f86b332104713b84b2491">operator const MemberType&amp; </a>()<span class="keyword">const</span>
<a name="l00055"></a>00055 <span class="keyword">            </span>{
<a name="l00056"></a>00056                 <span class="keywordflow">return</span> <span class="keyword">get</span>();
<a name="l00057"></a>00057             }
<a name="l00058"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a30d62260ec85f197672ad402c25fe6ac">00058</a>             MemberType&amp; <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a30d62260ec85f197672ad402c25fe6ac">operator = </a>( <span class="keyword">const</span> MemberType&amp; a )
<a name="l00059"></a>00059             {
<a name="l00060"></a>00060                 <span class="keywordflow">return</span> <span class="keyword">get</span>() = a;
<a name="l00061"></a>00061             }
<a name="l00062"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#afaa5e15dcdff29631fcdb547482797ef">00062</a>             <span class="keyword">const</span> MemberType&amp; <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#afaa5e15dcdff29631fcdb547482797ef">operator * </a>()<span class="keyword"> const</span>
<a name="l00063"></a>00063 <span class="keyword">            </span>{
<a name="l00064"></a>00064                 <span class="keywordflow">return</span> <span class="keyword">get</span>();
<a name="l00065"></a>00065             }
<a name="l00066"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a0da62c500336a6c6a157774a9ff98da4">00066</a>             MemberType&amp; <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#afaa5e15dcdff29631fcdb547482797ef">operator * </a>()
<a name="l00067"></a>00067             {
<a name="l00068"></a>00068                 <span class="keywordflow">return</span> <span class="keyword">get</span>();
<a name="l00069"></a>00069             }
<a name="l00070"></a>00070 
<a name="l00071"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a14497dbf8af31e80dba931514378657e">00071</a>             <span class="keyword">const</span> MemberType&amp; <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a14497dbf8af31e80dba931514378657e">operator -&gt; </a>()<span class="keyword"> const</span>
<a name="l00072"></a>00072 <span class="keyword">            </span>{
<a name="l00073"></a>00073                 <span class="keywordflow">return</span> <span class="keyword">get</span>();
<a name="l00074"></a>00074             }
<a name="l00075"></a>00075 
<a name="l00076"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a8dd82dbfc9d726374aeecb5a2dae0eaa">00076</a>             MemberType&amp; <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a14497dbf8af31e80dba931514378657e">operator -&gt; </a>() 
<a name="l00077"></a>00077             {
<a name="l00078"></a>00078                 <span class="keywordflow">return</span> <span class="keyword">get</span>();
<a name="l00079"></a>00079             }
<a name="l00080"></a>00080 
<a name="l00081"></a>00081             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;
<a name="l00082"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a3fa0d845580f8fcf58875435ab96d72e">00082</a>             <span class="keywordtype">void</span> <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a3fa0d845580f8fcf58875435ab96d72e">set_delegate</a>(  C*&amp; s, MemberType C::* m )
<a name="l00083"></a>00083             {
<a name="l00084"></a>00084                 MemberType&amp; (*do_get_impl)(C*, MemberType C::* ) = &amp;detail::do_get;
<a name="l00085"></a>00085                 <span class="keyword">get</span> = boost::bind( do_get_impl, s, m );
<a name="l00086"></a>00086             }
<a name="l00087"></a>00087 
<a name="l00088"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#ac7ac851e2975b4fe208e8efc7807252a">00088</a>             <span class="keyword">typedef</span> <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html">member</a> <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html">self_type</a>;
<a name="l00089"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#aac975bebde8bdc4124049da5f07e0745">00089</a>             <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html">member</a>&amp; <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#a30d62260ec85f197672ad402c25fe6ac">operator = </a>( <span class="keyword">const</span> boost::function&lt;MemberType&amp;()&gt; a ) { <span class="keyword">get</span> = a; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00090"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1member.html#aa8cdd378c2c0cb410956d15e66348a13">00090</a>             boost::function&lt;MemberType&amp;()&gt;                  <span class="keyword">get</span>;
<a name="l00091"></a>00091         };
<a name="l00092"></a>00092 
<a name="l00093"></a>00093         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00094"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1calculate__type.html">00094</a>         <span class="keyword">struct </span><a class="code" href="structboost_1_1idl_1_1detail_1_1calculate__type.html">calculate_type</a>
<a name="l00095"></a>00095         {
<a name="l00096"></a>00096         };
<a name="l00097"></a>00097 
<a name="l00098"></a>00098         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Class, <span class="keyword">typename</span> MemberType&gt;
<a name="l00099"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1calculate__type_3_01MemberType_07Class_1_1_5_08_4.html">00099</a>         <span class="keyword">struct </span><a class="code" href="structboost_1_1idl_1_1detail_1_1calculate__type.html">calculate_type</a>&lt;MemberType (Class::*)&gt;
<a name="l00100"></a>00100         {
<a name="l00101"></a><a class="code" href="structboost_1_1idl_1_1detail_1_1calculate__type_3_01MemberType_07Class_1_1_5_08_4.html#a46b45f6c754dfd35413b12d636dde88d">00101</a>             <span class="keyword">typedef</span>  <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html">boost::idl::detail::member&lt;Class,MemberType&gt;</a> <a class="code" href="structboost_1_1idl_1_1detail_1_1member.html">type</a>;
<a name="l00102"></a>00102         };
<a name="l00103"></a>00103 
<a name="l00104"></a>00104         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00105"></a>00105         boost::false_type implements_method( T );
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="preprocessor">#        ifndef BOOST_IDL_METHOD_IMPL_SIZE</span>
<a name="l00108"></a><a class="code" href="method_8hpp.html#ae5181212299a37e1ed0cd24a604bbb1b">00108</a> <span class="preprocessor"></span><span class="preprocessor">#           define BOOST_IDL_METHOD_IMPL_SIZE 8</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="preprocessor">#        endif</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span>
<a name="l00111"></a>00111 <span class="preprocessor">#       include &lt;boost/preprocessor/iteration/iterate.hpp&gt;</span>
<a name="l00112"></a><a class="code" href="method_8hpp.html#a32c85728220c00c69b807cc6da39ad40">00112</a> <span class="preprocessor">#       define BOOST_PP_ITERATION_LIMITS (0, BOOST_IDL_METHOD_IMPL_SIZE -1 )</span>
<a name="l00113"></a><a class="code" href="method_8hpp.html#a1ed7c98d32220d2344966959584f9778">00113</a> <span class="preprocessor"></span><span class="preprocessor">#       define BOOST_PP_FILENAME_1 &lt;boost/idl/method.hpp&gt;</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="preprocessor">#       include BOOST_PP_ITERATE()</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>
<a name="l00116"></a>00116 <span class="preprocessor">    #undef PARAM_NAME</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="preprocessor">    #undef PARAM_TYPE</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="preprocessor">    #undef PARAM_ARG</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span>
<a name="l00120"></a>00120     } } } <span class="comment">// namespace boost::idl::detail</span>
<a name="l00121"></a>00121 
<a name="l00122"></a>00122     <span class="comment">//#endif // _BOOST_IDL_METHOD_HPP_</span>
<a name="l00123"></a>00123 <span class="preprocessor">#else // BOOST_PP_IS_ITERATING</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span>
<a name="l00125"></a>00125 <span class="preprocessor">#define n BOOST_PP_ITERATION()</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span><span class="preprocessor">#define PARAM_NAMES     BOOST_PP_ENUM(n,PARAM_NAME,A) // name_N</span>
<a name="l00127"></a>00127 <span class="preprocessor"></span><span class="preprocessor">#define PARAM_ARGS      BOOST_PP_ENUM(n,PARAM_ARG,A) // TYPE_N name_N</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span>        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> R BOOST_PP_ENUM_TRAILING_PARAMS(n, <span class="keyword">typename</span> A)&gt;
<a name="l00129"></a>00129         <span class="keyword">struct </span>member_from_signature&lt;C, R(BOOST_PP_ENUM_PARAMS(n,A)), false&gt; 
<a name="l00130"></a>00130         { 
<a name="l00131"></a>00131             <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::remove_pointer&lt;R(C::*)(BOOST_PP_ENUM_PARAMS(n,A))&gt;::type type; 
<a name="l00132"></a>00132             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span>  arity    = n;
<a name="l00133"></a>00133             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const = <span class="keyword">false</span>;
<a name="l00134"></a>00134         };
<a name="l00135"></a>00135         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> R BOOST_PP_ENUM_TRAILING_PARAMS(n, <span class="keyword">typename</span> A)&gt;
<a name="l00136"></a>00136         <span class="keyword">struct </span>member_from_signature&lt;C, R(BOOST_PP_ENUM_PARAMS(n,A)), true&gt; 
<a name="l00137"></a>00137         { 
<a name="l00138"></a>00138             <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::remove_pointer&lt;R(C::*)(BOOST_PP_ENUM_PARAMS(n,A))const&gt;::type type; 
<a name="l00139"></a>00139             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span>  arity    = n;
<a name="l00140"></a>00140             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const = <span class="keyword">true</span>;
<a name="l00141"></a>00141         };
<a name="l00142"></a>00142 
<a name="l00143"></a>00143         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C BOOST_PP_ENUM_TRAILING_PARAMS(n, <span class="keyword">typename</span> A)&gt;
<a name="l00144"></a>00144         <span class="keyword">struct </span>calculate_type&lt;R(C::*)(BOOST_PP_ENUM_PARAMS(n,A))&gt; 
<a name="l00145"></a>00145         { 
<a name="l00146"></a>00146             <span class="keyword">typedef</span> boost::idl::fast_delegate&lt;R(BOOST_PP_ENUM_PARAMS(n,A))&gt;                    traits;
<a name="l00147"></a>00147             <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::remove_pointer&lt;R(C::*)(BOOST_PP_ENUM_PARAMS(n,A))&gt;::type member_type; 
<a name="l00148"></a>00148             <span class="keyword">typedef</span>  <a class="code" href="structboost_1_1idl_1_1detail_1_1method.html">boost::idl::detail::method</a>&lt; n,
<a name="l00149"></a>00149                                                  R( BOOST_PP_ENUM_PARAMS(n,A) ),
<a name="l00150"></a>00150                                                  <span class="keyword">false</span> &gt;  type;
<a name="l00151"></a>00151         };
<a name="l00152"></a>00152 
<a name="l00153"></a>00153         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C BOOST_PP_ENUM_TRAILING_PARAMS(n, <span class="keyword">typename</span> A)&gt;
<a name="l00154"></a>00154         <span class="keyword">struct </span>get_function_type&lt;R(C::*)(BOOST_PP_ENUM_PARAMS(n,A))&gt; 
<a name="l00155"></a>00155         { 
<a name="l00156"></a>00156             <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::remove_pointer&lt;R(C::*)(BOOST_PP_ENUM_PARAMS(n,A))&gt;::type type; 
<a name="l00157"></a>00157             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span>  arity = boost::function_traits&lt;R(BOOST_PP_ENUM_PARAMS(n,A))&gt;::arity;
<a name="l00158"></a>00158             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const = <span class="keyword">false</span>;
<a name="l00159"></a>00159         };
<a name="l00160"></a>00160         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C BOOST_PP_ENUM_TRAILING_PARAMS(n, <span class="keyword">typename</span> A)&gt;
<a name="l00161"></a>00161         <span class="keyword">struct </span>get_function_type&lt;R(C::*)(BOOST_PP_ENUM_PARAMS(n,A))const&gt; 
<a name="l00162"></a>00162         { 
<a name="l00163"></a>00163             <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::remove_pointer&lt;R(C::*)(BOOST_PP_ENUM_PARAMS(n,A))const&gt;::type type; 
<a name="l00164"></a>00164             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span>  arity = boost::function_traits&lt;R(BOOST_PP_ENUM_PARAMS(n,A))&gt;::arity;
<a name="l00165"></a>00165             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const = <span class="keyword">true</span>;
<a name="l00166"></a>00166         };
<a name="l00167"></a>00167 
<a name="l00168"></a>00168         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C BOOST_PP_ENUM_TRAILING_PARAMS(n, <span class="keyword">typename</span> A)&gt;
<a name="l00169"></a>00169         <span class="keyword">struct </span>calculate_type&lt;R(C::*)(BOOST_PP_ENUM_PARAMS(n,A))const&gt; 
<a name="l00170"></a>00170         { 
<a name="l00171"></a>00171             <span class="keyword">typedef</span> boost::idl::fast_delegate&lt;R(BOOST_PP_ENUM_PARAMS(n,A))&gt;                    traits;
<a name="l00172"></a>00172             <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::remove_pointer&lt;R(C::*)(BOOST_PP_ENUM_PARAMS(n,A))const&gt;::type member_type; 
<a name="l00173"></a>00173             <span class="keyword">typedef</span>  <a class="code" href="structboost_1_1idl_1_1detail_1_1method.html">boost::idl::detail::method</a>&lt; n,
<a name="l00174"></a>00174                                                  R( BOOST_PP_ENUM_PARAMS(n,A) ),
<a name="l00175"></a>00175                                                  <span class="keyword">true</span> &gt;  type;
<a name="l00176"></a>00176         };
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 
<a name="l00179"></a>00179         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Signature&gt;
<a name="l00180"></a>00180         <span class="keyword">struct </span>method&lt;n,Signature,false&gt;
<a name="l00181"></a>00181         {
<a name="l00182"></a>00182             <span class="keyword">typedef</span> Signature signature;
<a name="l00183"></a>00183             <span class="keyword">typedef</span> boost::function_traits&lt;Signature&gt; traits;
<a name="l00184"></a>00184             <span class="keyword">typedef</span> method&lt;n,Signature,false&gt; self_type;
<a name="l00185"></a>00185             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const = <span class="keyword">false</span>;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187             <span class="keyword">inline</span> <span class="keyword">typename</span> traits::result_type 
<a name="l00188"></a>00188                 operator()( PARAM_ARGS ) { <span class="keywordflow">return</span> m_delegate( PARAM_NAMES ); }
<a name="l00189"></a>00189             method&amp; operator=( <span class="keyword">const</span> boost::idl::fast_delegate&lt;Signature&gt;&amp; s )
<a name="l00190"></a>00190             { m_delegate = s; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00191"></a>00191  <span class="comment">//           private:</span>
<a name="l00192"></a>00192  
<a name="l00193"></a>00193             
<a name="l00194"></a>00194             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> M&gt;
<a name="l00195"></a>00195             <span class="keywordtype">void</span> set_delegate(  C*&amp; s, M m )
<a name="l00196"></a>00196             {
<a name="l00197"></a>00197                 m_delegate = make_delegate(s,m); 
<a name="l00198"></a>00198             }
<a name="l00199"></a>00199             boost::idl::fast_delegate&lt;Signature&gt; m_delegate;
<a name="l00200"></a>00200         };
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Signature&gt;
<a name="l00203"></a>00203         <span class="keyword">struct </span>method&lt;n,Signature,true&gt;
<a name="l00204"></a>00204         {
<a name="l00205"></a>00205             <span class="keyword">typedef</span> Signature signature;
<a name="l00206"></a>00206             <span class="keyword">typedef</span> boost::function_traits&lt;Signature&gt; traits;
<a name="l00207"></a>00207             <span class="keyword">typedef</span> method&lt;n,Signature,true&gt; self_type;
<a name="l00208"></a>00208             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const = <span class="keyword">true</span>;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210             <span class="keyword">inline</span> <span class="keyword">typename</span> traits::result_type 
<a name="l00211"></a>00211                 operator()( PARAM_ARGS )<span class="keyword">const </span>{ <span class="keywordflow">return</span> m_delegate( PARAM_NAMES ); }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213             method&amp; operator=( <span class="keyword">const</span> boost::idl::fast_delegate&lt;Signature&gt;&amp; s )
<a name="l00214"></a>00214             { m_delegate = s; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> M&gt;
<a name="l00217"></a>00217             <span class="keywordtype">void</span> set_delegate(  C*&amp; s, M m )
<a name="l00218"></a>00218             {
<a name="l00219"></a>00219                 m_delegate = make_delegate(s,m); 
<a name="l00220"></a>00220             }
<a name="l00221"></a>00221 <span class="comment">//            private:</span>
<a name="l00222"></a>00222             boost::idl::fast_delegate&lt;Signature&gt; m_delegate;
<a name="l00223"></a>00223         };
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="preprocessor">#undef PARAM_ARGS</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span><span class="preprocessor">#undef PARAM_NAMES</span>
<a name="l00228"></a>00228 <span class="preprocessor"></span><span class="preprocessor">#undef n</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span>
<a name="l00230"></a>00230 <span class="preprocessor">#endif // BOOST_PP_IS_ITERATING</span>
</pre></div></div>
<hr/>
<table border=0 width="100%">
<tr>
<td>
&copy; Daniel Larimer 2010-2011 - Licensed under <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>
</td>
<td>
</td>
<td align="right">
Boost IDL Library  
</td>
</tr>
</table>
