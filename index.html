<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Boost IDL Library: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Boost IDL Library Documentation</h1><h3 class="version">0.1.0 </h3><p>The Boost IDL library provides a means to quickly describe the interface of a class or struct and then use that description to provide compile-time and run-time reflection on the interface. The library was motivated by the desire to eliminate the amount of boiler plate code required to create variations on an interface for different pruposes.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This library is not part of the official Boost C++ libraries. It was developed with the intention of being submitted for review by the Boost community and therefore everything is coded accoding to the Boost C++ Coding Guidleines.</dd></dl>
<h2><a class="anchor" id="toc">
Table of Contents</a></h2>
<ul>
<li><a class="el" href="index.html#introduction">Introduction</a><ul>
<li><a class="el" href="index.html#motivation">Motivation</a></li>
<li><a class="el" href="index.html#reflection">Reflection</a></li>
<li><a class="el" href="index.html#type_erasure">Type Erasure</a></li>
</ul>
</li>
<li><a class="el" href="index.html#tutorial">Tutorial</a><ul>
<li><a class="el" href="index.html#type_erasure_def">Define your Interface</a></li>
<li><a class="el" href="index.html#type_erasure_any">Using idl::any&lt;InterfaceType&gt;</a></li>
<li><a class="el" href="index.html#implementation_detail">BOOST_IDL_INTERFACE() Implementation Details</a></li>
<li><a class="el" href="index.html#adapting_an_interface">Adapting an Interface</a></li>
</ul>
</li>
<li><a class="el" href="group__rpc__case__study.html">Remote Procedure Call Case Study</a></li>
<li><a class="el" href="index.html#rationale">Design Rationale</a></li>
<li><a class="el" href="index.html#future_dev">Future Development</a></li>
<li><a class="el" href="index.html#acknowledgements">Acknowledgements</a></li>
</ul>
<h2><a class="anchor" id="introduction">
Introduction</a></h2>
<p>There have been many libraries that attempt to provide Reflection tools for C++ programs. The most robust solution is the <a href="http://kifri.fri.uniza.sk/~chochlik/mirror-lib/html/">Boost Mirror library</a>. Despite its ability to reflect just about every c++ construct, the Boost Mirror library requires the developer to enter more text to describe the interface than it took to write the interface in the first place.</p>
<p>Boost.Idl attempts to find a middle ground with a focus on providing the most useful features while minimizing the amount of work a developer must do to reflect those properties. Boost.Idl goes one step further and provides a generic Type Erasure construct, boost::idl::any&lt;Interface&gt;.</p>
<h3><a class="anchor" id="motivation">
Motivation</a></h3>
<p>It is not uncommon for developers to write some code that needs to interface with many different systems in slightly different ways. The result is ususally the creation of many different "wrappers" each exposing the core function of an object in a slightly different way.</p>
<ul>
<li>Remote Procedure Client / Server Stubs</li>
<li>Scripting Language Hooks</li>
<li>Command Line Arguments</li>
<li>Actor Paradigmn</li>
<li>Configuration</li>
</ul>
<p>All of these tasks represent the creation of code that is derived from the core interface in a well defined manner. Each wrapper is tightly coupled to the core interface, such that if the core interface changes then all the wrappers must make a similar change. Coding these wrappers is the type of task that makes your hands ache just thinking about all of the mindless typing involved.</p>
<h3><a class="anchor" id="reflection">
Reflection</a></h3>
<p>The reflection provided by Boost.Idl focuses on exposing typenames, inheritance, return values, method names, parameter types, constness, and public member variables. All reflection is non-invasive and may be added to any class or struct.</p>
<h3><a class="anchor" id="type_erasure">
Type Erasure</a></h3>
<p>In the world of generic programming, type information tends to propogate as template parameters. <em>"Type Erasure is the process of turning a wide variety of
        types with a common interface into one type with that same interface."</em></p>
<ul>
<li><a href="http://www.boostpro.com/mplbook/">C++ Template Metaprogramming</a> by Dave Abrahams &amp; Aleksy Curtovoy</li>
</ul>
<p>More than that, you can adapt interfaces, morph inheritance based interfaces into value semantics, or perform other transformations on an interface in the process of 'erasing' its type.</p>
<p>Common uses of type erasure include boost::any and boost::function. Boost.Any erases all type information except its name and copy semantics. Boost.Function erases everything about a type except the calling signature. Algorithms written with Boost.Any and Boost.Function can be agnostic to the huge amount of type variation possible for functors, function pointers, member function pointers, or storage.</p>
<p>This article on <a href="http://www.artima.com/cppsource/type_erasure.html">type erasure</a> shows how Generic Programming (Templates) often conflicts with good Object Oriented design because generic programing exposes the internal implementation details that good Object Oriented design goes to great lengths to hide.</p>
<center><table  width="75%">
<tr>
<td>Good engineering involves compromise at every turn. A good, working, finished product is never pure by the standards of any one idiom or methodology. The art of good engineering is not the art of discovering and applying the one right idiom over all others. The art of good engineering is to know what your options are, and then to choose your trade-offs wisely rather than letting others choose them for you. </td><td></td></tr>
</table>
</center><p>I found the following quote from the article really helps put the debate between 'fast' generic programing and 'slow' object oriented programming.</p>
<center><table  width="75%">
<tr>
<td>Optimization whose effect no user ever notices is the root of many evils, among them the failure of software projects and the subsequent failure of businesses. </td><td></td></tr>
</table>
</center><p>Boost.IDL focuses on being as efficeint as possible without sacraficing development speed and proper Object Oriented abstraction. If you don't use boost::idl::any&lt;Interface&gt; in your inner loops, then your users will never notice one extra layer of indirection or an extra couple of bytes of RAM. Your company, managers, and customers will notice the cost savings in reducing your development time, decouping components, and added resiliance to change that developing with Boost.IDL can provide through type erasure.</p>
<h2><a class="anchor" id="tutorial">
Tutorial</a></h2>
<p>Boost.IDL makes the process of creating type erasures relatively easy via the idl::any&lt;InterfaceType&gt; class.</p>
<h3><a class="anchor" id="type_erasure_def">
Define your Interface</a></h3>
<p>This is all it takes to define an interface hierarchy using IDL. After defining this interface you can create a boost::idl::any&lt;Calculator&gt; or a boost::idl::any&lt;Service&gt; which can hold any object that provides these methods.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>Service
    {
        std::string name()<span class="keyword">const</span>;
        <span class="keywordtype">int</span>         exit();
    };
    <span class="keyword">struct </span>Calculator : Service
    {
        <span class="keywordtype">double</span> add( <span class="keywordtype">double</span> v );           
        <span class="keywordtype">double</span> sub( <span class="keywordtype">double</span> v );           
        <span class="keywordtype">double</span> mult( <span class="keywordtype">double</span> v );           
        <span class="keywordtype">double</span> div( <span class="keywordtype">double</span> v );           
        <span class="keywordtype">double</span> result()<span class="keyword">const</span>;
    };

    <a class="code" href="idl_8hpp.html#ac1a01eaad601dd1bb6d6de763d06f90c">BOOST_IDL_INTERFACE</a>( Service, <a class="code" href="idl_8hpp.html#a680acad0e78f5cd23c00fa9d8e3891e2">BOOST_IDL_BASE</a>, (name)(exit) )
    <a class="code" href="idl_8hpp.html#ac1a01eaad601dd1bb6d6de763d06f90c">BOOST_IDL_INTERFACE</a>( Calculator, (Service, <a class="code" href="idl_8hpp.html#a680acad0e78f5cd23c00fa9d8e3891e2">BOOST_IDL_BASE</a>), (add)(sub)(mult)(div)(result) )
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>When you define an interface, you need not provide implementations of the methods; however, it you want you may also use an interace like any other class without limititations.</dd></dl>
<h3><a class="anchor" id="type_erasure_any">
Using idl::any&lt;InterfaceType&gt;</a></h3>
<div class="fragment"><pre class="fragment">    <span class="keyword">class </span>CalculatorService
    {
        <span class="keyword">public</span>:
            CalculatorService():m_result(0){}

            std::string name()<span class="keyword">const            </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;CalculatorService&quot;</span>; }
            <span class="keywordtype">int</span>   exit()                       { ::exit(0);                  }
            <span class="keywordtype">double</span> add( <span class="keywordtype">double</span> v )             { <span class="keywordflow">return</span> m_result += v;       }
            <span class="keywordtype">double</span> sub( <span class="keywordtype">double</span> v )             { <span class="keywordflow">return</span> m_result -= v;       }
            <span class="keywordtype">double</span> mult( <span class="keywordtype">double</span> v )            { <span class="keywordflow">return</span> m_result *= v;       }
            <span class="keywordtype">double</span> div( <span class="keywordtype">double</span> v )             { <span class="keywordflow">return</span> m_result /= v;       }
            <span class="keywordtype">double</span> result()<span class="keyword">const               </span>{ <span class="keywordflow">return</span> m_result;            }

        <span class="keyword">private</span>:
            <span class="keywordtype">double</span> m_result;
    };

    <span class="keywordtype">void</span> try_it() {
        idl::any&lt;Calculator&gt; calc( CalculatorService() );
        calc.add(5);
        calc.add(6);
        assert( calc.result() == 11 );
    }
</pre></div><p>Some things to note, CalculatorService did not inherit either Calculator or Service, it simply exposed all of the methods defined by the interface. If it looks like a Duck, quacks like a Duck, then it is a Duck.</p>
<p>The interface of idl::any&lt;Calculator&gt; is 'identical' to the Calculator defined above.</p>
<h3><a class="anchor" id="implementation_detail">
BOOST_IDL_INTERFACE() Implementation Details</a></h3>
<p>Before this tutorial can continue to the section on <a class="el" href="index.html#adapting_an_interface">Adapting an Interface</a>, it is important to understand a bit about what the <a class="el" href="idl_8hpp.html#ac1a01eaad601dd1bb6d6de763d06f90c">BOOST_IDL_INTERFACE( )</a> macro is doing.</p>
<p>Below is a simplified version of what the macro generates intended to communicate the design, without getting into the implementation details.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>boost {
<span class="keyword">namespace </span>idl {
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> InterfaceDelegate &gt; 
<span class="keyword">class </span>any&lt;Calculator,InterfaceDelegate&gt; : <span class="keyword">public</span> boost::idl::any&lt;Service,InterfaceDelegate&gt;, 
                                          <span class="keyword">virtual</span> <span class="keyword">protected</span> boost::any 
{
<span class="keyword">public</span>:
     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
     any( T v ) :boost::any(v) {
          <a class="code" href="classboost_1_1idl_1_1set__delegate__visitor.html">boost::idl::set_delegate_visitor&lt;T&gt;</a> sd(boost::any_cast&lt;T&gt;( (boost::any*)(<span class="keyword">this</span>) ) );
          sd.start_visit(*<span class="keyword">this</span>);
     } 
     
     <span class="keyword">struct </span>__idl__add : 
        <span class="keyword">public</span> InterfaceDelegate::calculate_type&lt;typeof(&amp;Calculator::add)&gt;::type 
     {
         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type, <span class="keyword">typename</span> AssignType&gt;
         <span class="keyword">static</span> <span class="keywordtype">void</span> get_member_on_type( Type* t, AssignType&amp; v ) { v = t-&gt;add; }

         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
         <span class="keyword">static</span> typeof(&amp;T::add) get_member_on_type() { <span class="keywordflow">return</span> &amp;T::add; }
     } add;


     <span class="keyword">struct </span>__idl__sub : 
        <span class="keyword">public</span> InterfaceDelegate::calculate_type&lt;typeof(&amp;Calculator::sub)&gt;::type 
     {
         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type, <span class="keyword">typename</span> AssignType&gt;
         <span class="keyword">static</span> <span class="keywordtype">void</span> get_member_on_type( Type* t, AssignType&amp; v ) { v = t-&gt;sub; }

         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
         <span class="keyword">static</span> typeof(&amp;T::sub) get_member_on_type() { <span class="keywordflow">return</span> &amp;T::sub; }

     } sub;
<span class="comment"></span>
<span class="comment">     /**</span>
<span class="comment">        Implemented as a friend function to avoid poluting the interface.</span>
<span class="comment">     */</span>
     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Vi&gt; 
     <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> visit( any&amp; i, Vi&amp; v ) {
          i.__idl__visit(v);
     } 

<span class="keyword">protected</span>:
     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> __idl__visit( T&amp; t ) {
          any&lt;Service,InterfaceDelegate&gt;::__idl__visit(t);
          t.template accept&lt;Calculator&gt;( add, <span class="stringliteral">&quot;add&quot;</span> );
          t.template accept&lt;Calculator&gt;( sub, <span class="stringliteral">&quot;sub&quot;</span> );
     }
};
} } <span class="comment">// namespace boost::idl</span>
</pre></div><p>As you can see from the code above, BOOST_IDL_INTERFACE( ... ) performs a partial specialization of boost::idl::any&lt;Interface,InterfaceDelegate&gt; **within the boost::idl namespace**.</p>
<p>Each method listed in the macro becomes a public function object of a type determined by the InterfaceDelegate. Through proper definition of the InterfaceDelegate it is possible to change the return types, parameter types, and any other charistic of the interface.</p>
<p>The visit function passes a reference to each member function object along with its 'name' to the visitor's accept method. The visitor then has the power to inspect and/or modify the type of each member.</p>
<p>This approach is very flexible, but does have some down sides which will be addressed in the <a class="el" href="index.html#rationale">Design Rationale</a>.</p>
<h3><a class="anchor" id="adapting_an_interface">
Adapting an Interface</a></h3>
<p>The real power of Boost.IDL is its ability to dynamically adapt an interface. Suppose we want to expose our calculator to the user via a command line interface. Traditionally, this would require creating a loop that reads a method name, performs a giant if/else if/else block and then converts strings into the parameters appropriate for each method. This is not so bad for one-of solutions, but it becomes unmaintaible if there is a large number of interfaces that you want to expose in this manner *or* if the interface you are exposing is changing frequently.</p>
<p>Because Boost.IDL alows us to describe an interface, we can use this information to create a generic command line interpreter that can work with any interface where standard ostream/istream operators are defined for all of the parameters.</p>
<p>Boost.IDL uses the visitor design pattern to expose the type information. So to create our command line interpreter, we must define a visitor that converts each method into a function object that knows how to convert the parameters from strings, invoke the call, and then convert the return value back into a string. The methods must also be indexed by name so that we can dynamically dispatch them.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>cli : <span class="keyword">public</span> boost::idl::visitor&lt; cli &gt;
{
    <span class="keyword">public</span>:
       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InterfaceName, <span class="keyword">typename</span> M&gt;
       <span class="keywordtype">bool</span> accept( M&amp; m, <span class="keyword">const</span> <span class="keywordtype">char</span>* name )
       {
            <span class="comment">// print the method name, signature, and constness</span>
            std::cerr &lt;&lt; std::setw(10) &lt;&lt; std::setiosflags(std::ios::left) &lt;&lt; name 
                      &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="structboost_1_1idl_1_1get__typestring.html">boost::idl::get_typestring&lt;typename M::signature&gt;::str</a>()
                      &lt;&lt; (M::is_const ? <span class="stringliteral">&quot;const&quot;</span> : <span class="stringliteral">&quot;&quot;</span>) &lt;&lt;std::endl;

            <span class="comment">// create a function object and place it in our index, the parameter types</span>
            <span class="comment">// are available as a boost::fusion::vector&lt;&gt; typedef on the </span>
            <span class="comment">// member function object type</span>
            methods[name] = cli_functor&lt;typename M::fused_params, M&amp;&gt;(m);
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
       }
       boost::function&lt;std::string(const std::string&amp;)&gt;&amp; operator[]( <span class="keyword">const</span> std::string&amp; name ) 
       { <span class="keywordflow">return</span> methods[name]; }

   <span class="keyword">private</span>:
       <span class="comment">// Seq is boost::fusion::vector&lt;PARAM_TYPES&gt;</span>
       <span class="comment">// Functor is a reference to the member function object.</span>
       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq, <span class="keyword">typename</span> Functor&gt;
       <span class="keyword">struct </span>cli_functor
       {
           cli_functor( Functor f )
           :m_func(f){}

           std::string operator()( <span class="keyword">const</span> std::string&amp; cli )
           {
                std::stringstream ss(cli);
                Seq s; ss &gt;&gt; boost::fusion::tuple_delimiter(<span class="charliteral">&#39;,&#39;</span>) &gt;&gt; s;
                std::stringstream rtn;
                rtn &lt;&lt; m_func( s );
                <span class="keywordflow">return</span> rtn.str();
           }
           Functor m_func;
       };
       std::map&lt;std::string, boost::function&lt;std::string(const std::string)&gt; &gt; methods;
};
</pre></div><p>Once the visitor has been defined, it can be used with any interface defined by <a class="el" href="idl_8hpp.html#ac1a01eaad601dd1bb6d6de763d06f90c">BOOST_IDL_INTERFACE()</a>.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InterfaceType,<span class="keyword">typename</span> InterfaceDelegate&gt;
    <span class="keywordtype">void</span> start_cli( <a class="code" href="classboost_1_1idl_1_1any.html">boost::idl::any&lt;InterfaceType,InterfaceDelegate&gt;</a>&amp; a )
    {
        cli  m_cli;
        m_cli.start_visit(a);

        std::string line;
        std::string cmd;
        std::string args;

        <span class="keywordflow">while</span>( <span class="keyword">true</span> )
        {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Enter Method: &quot;</span>;
            std::getline( std::cin, line );
            cmd = line.substr( 0, line.find(<span class="charliteral">&#39;(&#39;</span>) );
            args = line.substr( cmd.size(), line.size() );
            std::cerr &lt;&lt; m_cli[cmd](args) &lt;&lt; std::endl;
        }
    }
</pre></div><h2><a class="anchor" id="rationale">
Design Rationale</a></h2>
<p>There has been discussion on the Boost mailing list regarding how the type erasure should be implemented. The obvious, "ideal", would be something where the 'weight' of the any&lt;&gt; is no more than boost::any. This approach would 'convert' any type passed into the constructor into a polymorphic type implementing the interface. Then the cost of a call is one virtual method invocation (assuming proper inlining).</p>
<p>This solution has already been implemented via <a href="http://www.cdiggins.com/bil.html">Boost.Interfaces</a>.</p>
<p>The interface declaration used by Boost.Interfaces is:</p>
<div class="fragment"><pre class="fragment">        BOOST_INTERFACE_BEGIN(IShape)
            BOOST_INTERFACE_CONST_FUNCTION0(GetX, <span class="keywordtype">int</span>)
            BOOST_INTERFACE_CONST_FUNCTION0(GetY, <span class="keywordtype">int</span>)
            BOOST_INTERFACE_CONST_FUNCTION0(GetArea, <span class="keywordtype">double</span>)
            BOOST_INTERFACE_FUNCTION2(SetXY, <span class="keywordtype">void</span>, (<span class="keywordtype">int</span>, x), (<span class="keywordtype">int</span>, y))
            BOOST_INTERFACE_FUNCTION2(OffSetXY, <span class="keywordtype">void</span>, (<span class="keywordtype">int</span>, x), (<span class="keywordtype">int</span>, y))
            BOOST_INTERFACE_CONST_FUNCTION0(GetName, const <span class="keywordtype">char</span>*)
        BOOST_INTERFACE_END(IShape)
</pre></div><p>Unfortunately, there is no clear way to define a macro based solution that achieves what Boost.Interfaces achieves without specifying your entire interface with the messy syntax above. A downside to the approach above is that any types that happen to contain a ',' would require special handling. A benefit to the above approach is that there is potential for knowng the parameter names in addition to the types.</p>
<p>I opted for a simpler syntax that can apply to pre-existing types along with the potential for more dynamic interface implementations rather than going for maximum possible performance or the minimum possible memory usage. With the proper "InterfaceDelegate", there is the potential that each method turns into a Don Clugston fast delegate. Thus you can get the 'fastest possible delegation' at the price of 16 bytes per method (on 64 bit machines) and a little extra one-time initialization cost.</p>
<h2><a class="anchor" id="future_dev">
Future Development</a></h2>
<p>At the moment the line is blurred between pointer semantics and value semantics on boost::idl::any&lt;&gt; such that the holder of the any does not know if they 'own' it or if they are simply 'pointing' to it. Ideally you would get something like:</p>
<ul>
<li>boost::idl::ptr&lt;InterfaceType&gt; holds a raw pointer</li>
<li>boost::idl::shared_ptr&lt;InterfaceType&gt; holds a boost::shared_ptr</li>
<li>boost::idl::any&lt;InterfaceType&gt; holds a value that is owned by the object</li>
</ul>
<p>The trick is to achieve this separation without incurring the cost of 'trippling' amount of code generated by the <a class="el" href="idl_8hpp.html#ac1a01eaad601dd1bb6d6de763d06f90c">BOOST_IDL_INTERFACE()</a> macro to handle each of these cases.</p>
<h2><a class="anchor" id="acknowledgements">
Acknowledgements</a></h2>
<p>Ideas, inspiration, and code were borrowed from:</p>
<ul>
<li><a href="http://www.cdiggins.com/bil.html">Boost.Interfaces</a> - Jonathan Turkanis &amp; Christopher Diggins.</li>
<li><a href="http://kifri.fri.uniza.sk/~chochlik/mirror-lib/html/">Boost.Mirror</a> - Matus Chochlik.</li>
<li><a href="http://www.codeproject.com/cpp/fast_delegate.asp">Fast Delegate</a> - Don Clugston.</li>
<li><a href="http://www.boostpro.com/mplbook/">C++ Template Metaprogramming</a> by Dave Abrahams &amp; Aleksy Curtovoy</li>
<li><a href="http://www.artima.com/cppsource/type_erasure.html">On the Tension Between Object-Oriented and Generic Programming in C++ and What Type Erasure Can Do About It</a> by Thomas Becker </li>
</ul>
</div>
<hr/>
<table border=0 width="100%">
<tr>
<td>
&copy; Daniel Larimer 2010-2011 - Licensed under <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>
</td>
<td>
</td>
<td align="right">
Boost IDL Library  
</td>
</tr>
</table>
