<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Boost Reflect Library: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Boost Reflect Library Documentation</h1><h3 class="version">0.1.0 </h3><p>The Boost Reflect library provides a means to quickly describe the interface of a class or struct and then use that description to provide compile-time and run-time reflection on the interface.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This library is not part of the official Boost C++ libraries. It was developed with the intention of being submitted for review by the Boost community and therefore everything is coded accoding to the Boost C++ Coding Guidlines.</dd></dl>
<h2><a class="anchor" id="toc">
Table of Contents</a></h2>
<ul>
<li><a class="el" href="group__boost__reflect__introduction.html">Introduction</a><ul>
<li><a class="el" href="group__boost__reflect__introduction.html#boost_reflect_motivation">Motivation</a></li>
<li><a class="el" href="group__boost__reflect__introduction.html#boost_reflect_reflection">Reflection</a></li>
<li><a class="el" href="group__boost__reflect__introduction.html#boost_reflect_type_erasure">Type Erasure</a></li>
</ul>
</li>
<li><a class="el" href="group__boost__reflect__quickstart.html">Quick Start</a><ul>
<li><a class="el" href="group__boost__reflect__quickstart.html#boost_reflect_basic">Basic Reflection</a></li>
<li><a class="el" href="group__boost__reflect__quickstart.html#boost_reflect_erasures">Type Erasures</a></li>
</ul>
</li>
<li><a class="el" href="index.html#boost_reflect_implementation_detail">Implementation Details</a></li>
<li><a class="el" href="index.html#boost_reflect_adapting_an_interface">Adapting an Interface</a></li>
<li><a class="el" href="index.html#boost_reflect_rationale">Design Rationale</a></li>
<li><a class="el" href="index.html#boost_reflect_future_dev">Future Development</a></li>
<li><a class="el" href="index.html#boost_reflect_acknowledgements">Acknowledgements</a></li>
</ul>
<h3><a class="anchor" id="boost_reflect_implementation_detail">
Implementation Details</a></h3>
<p>TBD</p>
<h3><a class="anchor" id="boost_reflect_adapting_an_interface">
Adapting an Interface</a></h3>
<p>TBD</p>
<h2><a class="anchor" id="boost_reflect_rationale">
Design Rationale</a></h2>
<p>There has been discussion on the Boost mailing list regarding how the type erasure should be implemented. The obvious, "ideal", would be something where the 'weight' of the any_ptr&lt;&gt; is no more than boost::any. This approach would 'convert' any type passed into the constructor into a polymorphic type implementing the interface. Then the cost of a call is one virtual method invocation (assuming proper inlining).</p>
<p>This solution has already been implemented via <a href="http://www.cdiggins.com/bil.html">Boost.Interfaces</a>.</p>
<p>The interface declaration used by Boost.Interfaces is:</p>
<div class="fragment"><pre class="fragment">        BOOST_INTERFACE_BEGIN(IShape)
            BOOST_INTERFACE_CONST_FUNCTION0(GetX, <span class="keywordtype">int</span>)
            BOOST_INTERFACE_CONST_FUNCTION0(GetY, <span class="keywordtype">int</span>)
            BOOST_INTERFACE_CONST_FUNCTION0(GetArea, <span class="keywordtype">double</span>)
            BOOST_INTERFACE_FUNCTION2(SetXY, <span class="keywordtype">void</span>, (<span class="keywordtype">int</span>, x), (<span class="keywordtype">int</span>, y))
            BOOST_INTERFACE_FUNCTION2(OffSetXY, <span class="keywordtype">void</span>, (<span class="keywordtype">int</span>, x), (<span class="keywordtype">int</span>, y))
            BOOST_INTERFACE_CONST_FUNCTION0(GetName, const <span class="keywordtype">char</span>*)
        BOOST_INTERFACE_END(IShape)
</pre></div><p>Unfortunately, there is no clear way to define a macro based solution that achieves what Boost.Interfaces achieves without specifying your entire interface with the (relatively) messy syntax above. A downside to the approach above is that any types that happen to contain a ',' would require special handling. A benefit to the above approach is that there is potential for knowng the parameter names in addition to the types.</p>
<p>I opted for a simpler syntax that can apply to pre-existing types along with the potential for more dynamic interface implementations rather than going for maximum possible performance or the minimum possible memory usage. With the proper "InterfaceDelegate", there is the potential that each method turns into a Don Clugston fast delegate. Thus you can get the 'fastest possible delegation' at the price of 16 bytes per method (on 64 bit machines) and a little extra one-time initialization cost.</p>
<h2><a class="anchor" id="boost_reflect_future_dev">
Future Development</a></h2>
<p>TBD</p>
<h2><a class="anchor" id="boost_reflect_acknowledgements">
Acknowledgements</a></h2>
<p>Ideas, inspiration, and code were borrowed from:</p>
<ul>
<li><a href="http://www.cdiggins.com/bil.html">Boost.Interfaces</a> - Jonathan Turkanis &amp; Christopher Diggins.</li>
<li><a href="http://kifri.fri.uniza.sk/~chochlik/mirror-lib/html/">Boost.Mirror</a> - Matus Chochlik.</li>
<li><a href="http://www.codeproject.com/cpp/fast_delegate.asp">Fast Delegate</a> - Don Clugston.</li>
<li><a href="http://www.boostpro.com/mplbook/">C++ Template Metaprogramming</a> by Dave Abrahams &amp; Aleksy Curtovoy</li>
<li><a href="http://www.artima.com/cppsource/type_erasure.html">On the Tension Between Object-Oriented and Generic Programming in C++ and What Type Erasure Can Do About It</a> by Thomas Becker </li>
</ul>
</div>
<hr/>
<table border=0 width="100%">
<tr>
<td>
&copy; Daniel Larimer 2010-2011 - Licensed under <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>
</td>
<td>
</td>
<td align="right">
Boost Reflect Library  
</td>
</tr>
</table>
<script type="text/javascript">

  var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-2423876-2']);
      _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                      })();

                      </script>
