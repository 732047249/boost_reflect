<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Boost Reflect Library: Design Rationale</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Design Rationale<br/>
<small>
[<a class="el" href="group__boost__reflect.html">Boost.Reflect</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p>There has been discussion on the Boost mailing list regarding how the type erasure should be implemented. The obvious, "ideal", would be something where the 'weight' of the any_ptr&lt;&gt; is no more than boost::any. This approach would 'convert' any type passed into the constructor into a polymorphic type implementing the interface. Then the cost of a call is one virtual method invocation (assuming proper inlining).</p>
<p>This solution has already been implemented via <a href="http://www.cdiggins.com/bil.html">Boost.Interfaces</a>.</p>
<p>The interface declaration used by Boost.Interfaces is:</p>
<div class="fragment"><pre class="fragment">        BOOST_INTERFACE_BEGIN(IShape)
            BOOST_INTERFACE_CONST_FUNCTION0(GetX, <span class="keywordtype">int</span>)
            BOOST_INTERFACE_CONST_FUNCTION0(GetY, <span class="keywordtype">int</span>)
            BOOST_INTERFACE_CONST_FUNCTION0(GetArea, <span class="keywordtype">double</span>)
            BOOST_INTERFACE_FUNCTION2(SetXY, <span class="keywordtype">void</span>, (<span class="keywordtype">int</span>, x), (<span class="keywordtype">int</span>, y))
            BOOST_INTERFACE_FUNCTION2(OffSetXY, <span class="keywordtype">void</span>, (<span class="keywordtype">int</span>, x), (<span class="keywordtype">int</span>, y))
            BOOST_INTERFACE_CONST_FUNCTION0(GetName, const <span class="keywordtype">char</span>*)
        BOOST_INTERFACE_END(IShape)
</pre></div><p>Unfortunately, there is no clear way to define a macro based solution that achieves what Boost.Interfaces achieves without specifying your entire interface with the (relatively) messy syntax above. A downside to the approach above is that any types that happen to contain a ',' would require special handling. A benefit to the above approach is that there is potential for knowng the parameter names in addition to the types.</p>
<p>I opted for a simpler syntax that can apply to pre-existing types along with the potential for more dynamic interface implementations rather than going for maximum possible performance or the minimum possible memory usage. With the proper "InterfaceDelegate", there is the potential that each method turns into a Don Clugston fast delegate. Thus you can get the 'fastest possible delegation' at the price of 16 bytes per method (on 64 bit machines) and a little extra one-time initialization cost. </p>
</div>
<hr/>
<table border=0 width="100%">
<tr>
<td>
&copy; Daniel Larimer 2010-2011 - Licensed under <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>
</td>
<td>
</td>
<td align="right">
Boost Reflect Library  
</td>
</tr>
</table>
<script type="text/javascript">

  var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-2423876-2']);
      _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                      })();

                      </script>
